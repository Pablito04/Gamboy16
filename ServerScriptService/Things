local MarketplaceService = game:GetService("MarketplaceService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local DataStoreService = game:GetService("DataStoreService")
local ServerStorage = game:GetService("ServerStorage")
local Players = game:GetService("Players")

local Things = require(ServerStorage.Modules:WaitForChild("Things"))
local Insert = require(ServerStorage.Modules:WaitForChild("Insert"))
local SetProperties = require(ServerStorage.Modules:WaitForChild("SetProperties"))
local AssetIds = require(ServerStorage.Configuration.Modules:WaitForChild("AssetIds"))
local Traits = require(ServerStorage.Configuration.Modules:WaitForChild("Traits"))

local Numbers = require(ReplicatedStorage.Modules:WaitForChild("Numbers"))
local Rebirths = require(ReplicatedStorage.Configuration.Modules:WaitForChild("Rebirths"))

local StealsOrderedDataStore = DataStoreService:GetOrderedDataStore("Steals")
local RebirthsOrderedDataStore= DataStoreService:GetOrderedDataStore("Rebirths")
local MoneyOrderedDataStore= DataStoreService:GetOrderedDataStore("Money")
local ThingsDataStore = DataStoreService:GetDataStore("Things")

local NotificationEvent = ReplicatedStorage.Remotes.Events:WaitForChild("Notification")

local Bases = workspace:WaitForChild("Bases")

local BasesData = {}
local BasesConnections = {}

local PlayersInFloors = {}

local function UpdateMultiplier(Player, MultiplierGui)
	local Leaderstats = Player:WaitForChild("leaderstats")
	local RebirthsValue = Leaderstats:WaitForChild("Rebirths")

	local Configuration = Player:WaitForChild("Configuration")
	local FriendsValue = Configuration:WaitForChild("Friends")
	local MultiplierValue = Configuration:WaitForChild("Multiplier")
	local IndexMultiplierValue = Configuration:WaitForChild("IndexMultiplier")

	local Rebirth = RebirthsValue.Value
	local RebirthConfig = Rebirths[Rebirth]

	local RebirthMultiplier = 0
	if RebirthConfig and RebirthConfig.Unlocks and RebirthConfig.Unlocks.Multiplier then
		RebirthMultiplier = RebirthConfig.Unlocks.Multiplier
	end

	local BaseMultiplier = 1
	local FriendsBonus = FriendsValue.Value * 0.1
	local IndexMultiplier = IndexMultiplierValue.Value

	local TotalMultiplier = BaseMultiplier + RebirthMultiplier + FriendsBonus + IndexMultiplier
	MultiplierValue.Value = TotalMultiplier
end

local function UpdateFriends()
	for _, Player in ipairs(Players:GetPlayers()) do
		local Configuration = Player:WaitForChild("Configuration")
		local FriendsValue = Configuration:WaitForChild("Friends")

		local Friends = 0
		local Success, FriendPages = pcall(function()
			return Players:GetFriendsAsync(Player.UserId)
		end)

		if not Success or not FriendPages then
			continue
		end

		local OtherUserIds = {}
		for _, OtherPlayer in ipairs(Players:GetPlayers()) do
			OtherUserIds[OtherPlayer.UserId] = true
		end

		while true do
			local FriendPage = FriendPages:GetCurrentPage()
			for _, FriendData in ipairs(FriendPage) do
				if OtherUserIds[FriendData.Id] then
					Friends += 1
				end
			end

			local Success = pcall(function()
				FriendPages:AdvanceToNextPageAsync()
			end)

			if not Success or FriendPages.IsFinished then
				break
			end
		end

		FriendsValue.Value = Friends
	end
end

local function LoadThings(Player)
	local Base = Player:FindFirstChild("Configuration") and Player.Configuration:FindFirstChild("Base") and Player.Configuration.Base.Value
	if not Base then return end

	local Slots = Base:FindFirstChild("Slots")
	if not Slots then return end

	Slots = Slots:GetChildren()
	
	table.sort(Slots, function(A, B)
		local AIndex = tonumber(string.match(A.Name, "%d+")) or 0
		local BIndex = tonumber(string.match(B.Name, "%d+")) or 0
		return AIndex < BIndex
	end)

	local Success, ThingsSavedData = pcall(function()
		return ThingsDataStore:GetAsync(tostring(Player.UserId))
	end)

	if not Success or not ThingsSavedData then return end

	local ThingsAmount = 0
	for _ in pairs(ThingsSavedData) do
		ThingsAmount += 1
	end

	if ThingsAmount > #Slots then
		NotificationEvent:FireClient(Player, "Too many saved things to load!", false)
		return
	end

	for Index, ThingSavedData in pairs(ThingsSavedData) do
		local Slot = Slots[tonumber(Index)]
		if Slot then
			local SavedTraits = ThingSavedData.Traits or ""

			local AppliedTraits = {}
			for TraitName in string.gmatch(SavedTraits, "([^,]+)") do
				TraitName = TraitName:gsub("^%s*(.-)%s*$", "%1")
				table.insert(AppliedTraits, TraitName)
			end

			task.spawn(Things.Add, Player, Base, Slot, ThingSavedData.Name, AppliedTraits, ThingSavedData.Mutation, ThingSavedData.Time)
		end
	end
end

local function SaveThings(Player)
	local Base = Player:FindFirstChild("Configuration") and Player.Configuration:FindFirstChild("Base") and Player.Configuration.Base.Value
	if not Base then return end

	local Slots = Base:FindFirstChild("Slots")
	if not Slots then return end

	Slots = Slots:GetChildren()

	table.sort(Slots, function(A, B)
		local AIndex = tonumber(string.match(A.Name, "%d+")) or 0
		local BIndex = tonumber(string.match(B.Name, "%d+")) or 0
		return AIndex < BIndex
	end)

	local ThingsSavedData = {}

	for Index, Slot in ipairs(Slots) do
		local Thing = Slot.Configuration.Thing.Value
		if not Thing then continue end

		local ThingAttachment = Thing.PrimaryPart:FindFirstChild("ThingAttachment")
		local ThingGui = ThingAttachment and ThingAttachment:FindFirstChild("ThingGui")
		local Stolen = ThingGui and ThingGui:FindFirstChild("Stolen")

		if Slot.Configuration.Occupied.Value and Thing.Parent == Slot and ThingGui and Stolen and not Stolen.Visible then
			local ThingConfiguration = Thing:FindFirstChild("Configuration")
			local MutationValue = ThingConfiguration and ThingConfiguration:FindFirstChild("Mutation")
			local TraitsValue = ThingConfiguration and ThingConfiguration:FindFirstChild("Traits")

			local Mutation = MutationValue and MutationValue.Value or "Default"
			local AppliedTraits = TraitsValue and TraitsValue.Value or ""

			ThingsSavedData[tostring(Index)] = {
				Name = Thing.Name,
				Mutation = Mutation,
				Traits = AppliedTraits,
				Time = os.time()
			}
		end
	end
	
	pcall(function()
		ThingsDataStore:SetAsync(tostring(Player.UserId), ThingsSavedData)
	end)
end

local function GetUnlockedFloors(Base, RebirthsAmount)
	if not RebirthsAmount or type(RebirthsAmount) ~= "number" then
		return {}
	end

	local UnlockedFloors = {}
	local Added = {}

	local function AddUnlockedFloor(Number)
		local Pattern = string.format("^Floor%d.*", Number)
		for _, Floor in pairs(Base.Floors:GetChildren()) do
			if Floor:IsA("Model") and Floor.Name:match(Pattern) and not Added[Floor] then
				table.insert(UnlockedFloors, Floor)
				Added[Floor] = true
			end
		end
	end

	AddUnlockedFloor(1)

	for Index = 1, RebirthsAmount do
		local Data = Rebirths[Index]
		if Data and Data.Unlocks and Data.Unlocks.Floor then
			AddUnlockedFloor(Data.Unlocks.Floor)
		end
	end

	return UnlockedFloors
end

local function GetUnlockedDoors(Base, RebirthsAmount)
	local UnlockedDoors = {}
	local UnlockedFloors = GetUnlockedFloors(Base, RebirthsAmount)

	for _, Floor in ipairs(UnlockedFloors) do
		local Doors = Floor:FindFirstChild("Doors")
		if Doors then
			for _, Door in ipairs(Doors:GetChildren()) do
				table.insert(UnlockedDoors, Door)
			end
		end
	end

	return UnlockedDoors
end

local function RefreshFriends()
	for _, Player in ipairs(Players:GetPlayers()) do
		local Configuration = Player:FindFirstChild("Configuration")
		local Base = Configuration and Configuration:FindFirstChild("Base") and Configuration.Base.Value
		if not Base then continue end

		local BaseData = BasesData[Base]
		if not BaseData or not BaseData.Allowed then continue end

		local Rebirths = Player:FindFirstChild("leaderstats") and Player.leaderstats:FindFirstChild("Rebirths")
		if not Rebirths then continue end

		local Success, Pages = pcall(function()
			return Players:GetFriendsAsync(Player.UserId)
		end)
		if not Success then continue end

		local OnlinePlayers = Players:GetPlayers()
		local OnlineIds = {}
		
		for _, OnlinePlayer in ipairs(OnlinePlayers) do
			OnlineIds[OnlinePlayer.UserId] = OnlinePlayer
		end

		local UnlockedDoors = GetUnlockedDoors(Base, Rebirths.Value)
		local NewAllowedFriends = {}

		repeat
			local Friends = Pages:GetCurrentPage()
			for _, Friend in ipairs(Friends) do
				local FriendPlayer = OnlineIds[Friend.Id]
				if FriendPlayer then
					NewAllowedFriends[FriendPlayer] = true

					for _, Door in ipairs(UnlockedDoors) do
						for _, Descendant in ipairs(Door:GetDescendants()) do
							if Descendant:IsA("BasePart") then
								SetProperties.Client(FriendPlayer, Descendant, {CanCollide = false})
							end
						end

						local ProximityPrompt = Door.Hitbox:FindFirstChild("ProximityPrompt")
						if ProximityPrompt then
							SetProperties.Client(FriendPlayer, ProximityPrompt, {Enabled = false})
						end
					end
				end
			end
		until Pages.IsFinished or not pcall(function() Pages:AdvanceToNextPageAsync() end)

		for OldFriend in pairs(BaseData.AllowedFriends) do
			if not NewAllowedFriends[OldFriend] and OldFriend:IsDescendantOf(Players) then
				for _, Door in ipairs(UnlockedDoors) do
					for _, Descendant in ipairs(Door:GetDescendants()) do
						if Descendant:IsA("BasePart") then
							SetProperties.Client(OldFriend, Descendant, {CanCollide = true})
						end
					end

					local ProximityPrompt = Door.Hitbox:FindFirstChild("ProximityPrompt")
					if ProximityPrompt then
						SetProperties.Client(OldFriend, ProximityPrompt, {Enabled = true})
					end
				end
			end
		end

		BaseData.AllowedFriends = NewAllowedFriends
	end
end

local function UpdateBase(Player)
	local Leaderstats = Player:WaitForChild("leaderstats")
	local RebirthsValue = Leaderstats and Leaderstats:WaitForChild("Rebirths")
	if not RebirthsValue then return end

	local Configuration = Player:FindFirstChild("Configuration")
	local Base = Configuration and Configuration:FindFirstChild("Base") and Configuration.Base.Value
	if not Base then return end

	local RebirthsAmount = RebirthsValue.Value

	for _, Slot in ipairs(Base.Slots:GetChildren()) do
		local Configuration = Slot:FindFirstChild("Configuration")
		if not Configuration then continue end

		local Thing = Configuration:FindFirstChild("Thing")
		if not Thing then continue end

		local Rebirth = Configuration:FindFirstChild("Rebirth")
		if not Rebirth or not Rebirth.Value then continue end
		
		local IsUnlocked = RebirthsValue.Value >= Rebirth.Value

		for _, Child in ipairs(Slot:GetChildren()) do
			if Child ~= Thing.Value then
				if Child:IsA("BasePart") then
					Child.Transparency = IsUnlocked and 0 or 1
					Child.CanCollide = IsUnlocked
				end

				for _, Descendant in ipairs(Child:GetDescendants()) do
					if Descendant:IsA("BasePart") then
						Descendant.Transparency = IsUnlocked and 0 or 1
						Descendant.CanCollide = IsUnlocked
					end
				end
			end
		end
	end

	local UnlockedFloors = GetUnlockedFloors(Base, RebirthsAmount)
	local Added = {}
	for _, Floor in ipairs(UnlockedFloors) do
		Added[Floor] = true
	end

	for _, Floor in ipairs(Base.Floors:GetChildren()) do
		local IsUnlocked = Added[Floor] == true

		for _, Child in ipairs(Floor:GetChildren()) do
			if Child.Name ~= "Hitbox" and Child.Name ~= "Doors" then
				if Child:IsA("BasePart") then
					Child.Transparency = IsUnlocked and 0 or 1
					Child.CanCollide = IsUnlocked
				end

				for _, Descendant in ipairs(Child:GetDescendants()) do
					if Descendant:IsA("BasePart") then
						Descendant.Transparency = IsUnlocked and 0 or 1
						Descendant.CanCollide = IsUnlocked
					end
				end
			end
		end

		if not IsUnlocked then
			for _, Descendant in ipairs(Floor:GetDescendants()) do
				if Descendant:IsA("BasePart") and Descendant.Name ~= "Hitbox" then
					Descendant.Transparency = 1
					Descendant.CanCollide = false
				end
			end
		end
	end

	local BaseData = BasesData[Base]
	if not BasesData then return end

	local UnlockedDoors = GetUnlockedDoors(Base, RebirthsAmount)
	for _, Door in ipairs(UnlockedDoors) do
		for _, Descendant in ipairs(Door:GetDescendants()) do
			if not Descendant:IsA("BasePart") then continue end

			Descendant.CanCollide = BaseData.Locked

			if BaseData.Locked then
				SetProperties.Client(Player, Descendant, {CanCollide = false})

				if BaseData.Allowed then
					for FriendPlayer in pairs(BaseData.AllowedFriends) do
						if FriendPlayer:IsDescendantOf(Players) then
							SetProperties.Client(FriendPlayer, Descendant, {CanCollide = false})
						end
					end
				end
			end

			if Descendant.Name == "Hitbox" then continue end

			Descendant.Transparency = BaseData.Locked and 0 or 1
		end
	end

	for _, Door in ipairs(UnlockedDoors) do
		local Hitbox = Door:FindFirstChild("Hitbox")
		if not Hitbox then continue end

		local ExistingPrompt = Hitbox:FindFirstChild("ProximityPrompt")
		if not ExistingPrompt then
			local ProximityPrompt = Insert.ProximityPrompt(Hitbox)
			ProximityPrompt.ActionText = "Unlock Base"
			ProximityPrompt.HoldDuration = 0.25

			ProximityPrompt.Triggered:Connect(function(TriggeringPlayer)
				if TriggeringPlayer == Player then return end
				
				if not BaseData.Locked then
					NotificationEvent:FireClient(TriggeringPlayer, "Base already unlocked!", false)
					return
				end
				
				if BaseData.Starter then
					NotificationEvent:FireClient(TriggeringPlayer, "Base loading!", false)
					return
				end
				
				MarketplaceService:PromptProductPurchase(TriggeringPlayer, AssetIds.DeveloperProducts.UnlockBase)
			end)
		end
	end
	
	if BaseData.Locked then
		for _, Door in ipairs(UnlockedDoors) do
			local DoorProximityPrompt = Door.Hitbox:FindFirstChild("ProximityPrompt")
			if not DoorProximityPrompt then continue end

			SetProperties.AllClients(DoorProximityPrompt, {Enabled = true})
			SetProperties.Client(Player, DoorProximityPrompt, {Enabled = false})

			if BaseData.Allowed then
				for FriendPlayer in pairs(BaseData.AllowedFriends) do
					if FriendPlayer:IsDescendantOf(Players) then
						SetProperties.Client(FriendPlayer, DoorProximityPrompt, {Enabled = false})
					end
				end
			end
		end
	end
end

local function GetSlotFloorNumber(Base, SlotRebirthValue)
	if SlotRebirthValue == 0 then
		local Floor1Folder = Base.Floors:FindFirstChild("Floor1")
		return Floor1Folder and 1 or nil
	else
		local ClosestRebirth = math.huge
		local SlotFloorNumber = nil
		for RebirthLevel, Data in pairs(Rebirths) do
			local FloorNumber = Data.Unlocks.Floor
			if FloorNumber and RebirthLevel >= SlotRebirthValue and RebirthLevel < ClosestRebirth then
				ClosestRebirth = RebirthLevel
				SlotFloorNumber = FloorNumber
			end
		end
		return SlotFloorNumber
	end
end

local function SetBase(Player)
	local AvailableBases = {}

	for _, Base in pairs(Bases:GetChildren()) do
		if not Base.Configuration.Player.Value then
			table.insert(AvailableBases, Base)
		end
	end

	if #AvailableBases == 0 then
		Player:Kick("No available Bases.")
		return
	end

	local RandomIndex = math.random(1, #AvailableBases)
	local Base = AvailableBases[RandomIndex]

	local Leaderstats = Player:WaitForChild("leaderstats")
	local RebirthsValue = Leaderstats:WaitForChild("Rebirths")

	local Configuration = Player:WaitForChild("Configuration")
	local BaseValue = Configuration:WaitForChild("Base")
	local MultiplierValue = Configuration:WaitForChild("Multiplier")

	BasesConnections[Base] = {}

	Base.Configuration.Player.Value = Player
	BaseValue.Value = Base
	
	local CharacterAddedConnection = Player.CharacterAdded:Connect(function(Character)
		local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
		local Humanoid = Character:WaitForChild("Humanoid")

		local AssignedBase = Player:FindFirstChild("Configuration") and Player.Configuration:FindFirstChild("Base") and Player.Configuration.Base.Value
		if AssignedBase and AssignedBase:FindFirstChild("Spawn") then
			local SpawnPart = AssignedBase.Spawn
			local OffsetY = Humanoid.HipHeight + (HumanoidRootPart.Size.Y / 2) + (SpawnPart.Size.Y / 2)
			local SpawnCFrame = SpawnPart.CFrame + Vector3.new(0, OffsetY, 0)

			Character:PivotTo(SpawnCFrame)
		end
	end)

	table.insert(BasesConnections[Base], CharacterAddedConnection)
	
	BasesData[Base] = {
		Locked = false,
		Starter = false,
		Allowed = false,
		AllowedFriends = {}
	}
	
	local BaseData = BasesData[Base]

	local Debounce = false

	local LockAttachment, LockGui = Insert.Lock(Base.Lock)

	local function Unlock()
		if not LockGui then return end
		if not LockGui:FindFirstChild("Lock") then return end

		LockGui.Lock.Text = "Lock"
		LockGui.Lock.TextColor3 = Color3.fromRGB(0, 255, 0)

		LockGui.Time.Visible = false

		local UnlockedDoors = GetUnlockedDoors(Base, RebirthsValue.Value)
		for _, Door in ipairs(UnlockedDoors) do
			for _, Descendant in ipairs(Door:GetDescendants()) do
				if not Descendant:IsA("BasePart") then continue end

				Descendant.CanCollide = false
				Descendant.Transparency = 1
			end
		end

		BaseData.Locked = false
	end

	local function Lock(Time)
		if not LockGui then return end

		BaseData.Locked = true

		LockGui.Lock.Text = "Locked"
		LockGui.Lock.TextColor3 = Color3.fromRGB(250, 0, 0)

		LockGui.Time.Visible = true
		LockGui.Time.Text = Numbers.Time(Time)

		local UnlockedDoors = GetUnlockedDoors(Base, RebirthsValue.Value)
		for _, Door in ipairs(UnlockedDoors) do
			for _, Descendant in ipairs(Door:GetDescendants()) do
				if not Descendant:IsA("BasePart") then continue end

				Descendant.CanCollide = true

				SetProperties.Client(Player, Descendant, {CanCollide = false})

				if BaseData.Allowed then
					for FriendPlayer in pairs(BaseData.AllowedFriends) do
						if FriendPlayer:IsDescendantOf(Players) then
							SetProperties.Client(FriendPlayer, Descendant, {CanCollide = false})
						end
					end
				end

				if Descendant.Name == "Hitbox" then continue end

				Descendant.Transparency = 0
			end
		end

		for _, Door in ipairs(UnlockedDoors) do
			local DoorProximityPrompt = Door.Hitbox:FindFirstChild("ProximityPrompt")
			if not DoorProximityPrompt then continue end

			SetProperties.AllClients(DoorProximityPrompt, {Enabled = true})
			SetProperties.Client(Player, DoorProximityPrompt, {Enabled = false})

			if BaseData.Allowed then
				for FriendPlayer in pairs(BaseData.AllowedFriends) do
					if FriendPlayer:IsDescendantOf(Players) then
						SetProperties.Client(FriendPlayer, DoorProximityPrompt, {Enabled = false})
					end
				end
			end
		end

		if not BaseData.Starter then
			NotificationEvent:FireClient(Player, string.format("Locked base for %ss!", Time), true)
		end

		task.spawn(function()
			while Time > 0 and Player and BaseData.Locked and LockGui do
				task.wait(1)
				
				Time -= 1
				
				if LockGui and LockGui:FindFirstChild("Time") then
					LockGui.Time.Text = Numbers.Time(Time)
				end
			end

			local UnlockedDoors = GetUnlockedDoors(Base, RebirthsValue.Value)
			for _, Door in ipairs(UnlockedDoors) do
				local DoorProximityPrompt = Door.Hitbox:FindFirstChild("ProximityPrompt")
				if not DoorProximityPrompt then continue end

				SetProperties.AllClients(DoorProximityPrompt, {Enabled = false})
			end

			BaseData.Starter = false
			Unlock()
		end)
	end

	UpdateBase(Player)
	
	if math.random() > 0.25 then
		AssetIds.DeveloperProducts.UnlockBase = 3321655179
	end
	
	local PromptProductPurchaseFinishedConnection = MarketplaceService.PromptProductPurchaseFinished:Connect(function(UserId, AssetId, IsPurchased)
		local Success, PurchasingPlayer = pcall(function()
			return Players:GetPlayerByUserId(UserId)
		end)

		if not (IsPurchased and Success and PurchasingPlayer and PurchasingPlayer ~= Player) or AssetId ~= AssetIds.DeveloperProducts.UnlockBase then
			return
		end

		if not BaseData.Locked then
			NotificationEvent:FireClient(PurchasingPlayer, "Base already unlocked!", false)
			return
		end

		if BaseData.Starter then
			NotificationEvent:FireClient(PurchasingPlayer, "Unable to unlock fresh base!", false)
			return
		end

		local UnlockedDoors = GetUnlockedDoors(Base, RebirthsValue.Value)
		for _, Door in ipairs(UnlockedDoors) do
			local DoorProximityPrompt = Door.Hitbox:FindFirstChild("ProximityPrompt")
			if not DoorProximityPrompt then continue end

			SetProperties.AllClients(DoorProximityPrompt, {Enabled = false})
		end

		Unlock()

		NotificationEvent:FireClient(PurchasingPlayer, "Unlocked base!", true)
	end)

	table.insert(BasesConnections[Base], PromptProductPurchaseFinishedConnection)

	BaseData.Starter = true
	Lock(30)

	local LockConnection = Base.Lock.Touched:Connect(function(Hit)
		local Character = Hit.Parent
		local TouchingPlayer = Players:GetPlayerFromCharacter(Character)
		if not TouchingPlayer then return end

		if Debounce then return end

		Debounce = true

		task.delay(1, function()
			Debounce = false
		end)

		if TouchingPlayer == Player and not BaseData.Locked then
			local Time = 60

			for Rebirth = 1, RebirthsValue.Value do
				local RebirthConfiguration = Rebirths[Rebirth]
				if RebirthConfiguration and RebirthConfiguration.Unlocks and RebirthConfiguration.Unlocks.Time then
					Time += RebirthConfiguration.Unlocks.Time
				end
			end

			Lock(Time, false)
		else
			NotificationEvent:FireClient(Player, "Base already locked!", false)
		end
	end)

	table.insert(BasesConnections[Base], LockConnection)

	local FriendsProximityPrompt = Insert.ProximityPrompt(Base.Friends)
	FriendsProximityPrompt.ActionText = BaseData.Allowed and "Disallow" or "Allow"
	FriendsProximityPrompt.HoldDuration = 1
	FriendsProximityPrompt.ObjectText = "Friends"

	SetProperties.Client(Player, FriendsProximityPrompt, {Enabled = true})

	local FriendsAttachment, FriendsGui, FriendsSurfaceGui = Insert.Friends(Base.Friends)

	FriendsSurfaceGui.Indicator.ImageColor3 = BaseData.Allowed and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
	
	FriendsProximityPrompt.Triggered:Connect(function(TriggeringPlayer)
		if TriggeringPlayer ~= Player then return end

		BaseData.Allowed = not BaseData.Allowed
		FriendsProximityPrompt.ActionText = BaseData.Allowed and "Disallow" or "Allow"
		FriendsSurfaceGui.Indicator.ImageColor3 = BaseData.Allowed and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)

		NotificationEvent:FireClient(Player, string.format("%s friends!", BaseData.Allowed and "Allowed" or "Disallowed"), BaseData.Allowed)

		if not BaseData.Allowed and BaseData.Locked then
			for FriendPlayer in pairs(BaseData.AllowedFriends) do
				if FriendPlayer:IsDescendantOf(Players) then
					local UnlockedDoors = GetUnlockedDoors(Base, RebirthsValue.Value)
					for _, Door in ipairs(UnlockedDoors) do
						for _, Descendant in ipairs(Door:GetDescendants()) do
							if not Descendant:IsA("BasePart") then continue end
							SetProperties.Client(FriendPlayer, Descendant, {CanCollide = true})
						end
					end

					for _, Door in ipairs(GetUnlockedDoors(Base, RebirthsValue.Value)) do
						local ProximityPrompt = Door.Hitbox:FindFirstChild("ProximityPrompt")
						if ProximityPrompt then
							SetProperties.Client(FriendPlayer, ProximityPrompt, {Enabled = true})
						end
					end
				end
			end

			table.clear(BaseData.AllowedFriends)
			return
		end

		RefreshFriends()
		UpdateBase(Player)
	end)

	local MultiplierAttachment, MultiplierGui = Insert.Multiplier(Base.CollectZone)
	local CollectZoneGui = Insert.CollectZone(Base.CollectZone)

	MultiplierValue:GetPropertyChangedSignal("Value"):Connect(function()
		MultiplierGui.Multiplier.Text = string.format("x%.1f", MultiplierValue.Value):gsub("%.0+$", ""):gsub("(%.%d-)0+$", "%1")
	end)

	local OwnerGui, OwnerSurfaceGui = Insert.Owner(Base.Owner)
	
	SetProperties.Client(Player, OwnerGui, {Enabled = true})
	
	OwnerSurfaceGui.DisplayName.Text = Player.DisplayName

	for _, FloorFolder in ipairs(Base.Floors:GetChildren()) do
		local Hitbox = FloorFolder:FindFirstChild("Hitbox")
		if Hitbox and Hitbox:IsA("BasePart") then
			local FloorNumber = tonumber(FloorFolder.Name:match("%d+"))
			if not FloorNumber then continue end

			local HitboxTouchedConnection = Hitbox.Touched:Connect(function(OtherPart)
				local TouchingPlayer = Players:GetPlayerFromCharacter(OtherPart.Parent)
				if not TouchingPlayer then return end

				PlayersInFloors[TouchingPlayer] = FloorNumber

				for _, Slot in ipairs(Base.Slots:GetChildren()) do
					local Configuration = Slot:FindFirstChild("Configuration")
					if not Configuration then continue end

					local ThingValue = Configuration:FindFirstChild("Thing")
					if not ThingValue or not ThingValue.Value then continue end

					local Rebirth = Configuration:FindFirstChild("Rebirth")
					if not Rebirth then continue end

					local SlotFloorNumber = GetSlotFloorNumber(Base, Rebirth.Value)
					if SlotFloorNumber == FloorNumber then
						local ProximityPrompt = ThingValue.Value:FindFirstChildWhichIsA("ProximityPrompt", true)
						if ProximityPrompt then
							SetProperties.Client(TouchingPlayer, ProximityPrompt, {Enabled = true})
						end
					end
				end
			end)

			local HitboxTouchEndedConnection = Hitbox.TouchEnded:Connect(function(OtherPart)
				local TouchingPlayer = Players:GetPlayerFromCharacter(OtherPart.Parent)
				if not TouchingPlayer then return end

				PlayersInFloors[TouchingPlayer] = FloorNumber

				if PlayersInFloors[TouchingPlayer] == FloorNumber then
					PlayersInFloors[TouchingPlayer] = nil

					for _, Slot in ipairs(Base.Slots:GetChildren()) do
						local Configuration = Slot:FindFirstChild("Configuration")
						if not Configuration then continue end

						local ThingValue = Configuration:FindFirstChild("Thing")
						if not ThingValue or not ThingValue.Value then continue end

						local Rebirth = Configuration:FindFirstChild("Rebirth")
						if not Rebirth then continue end

						local SlotFloorNumber = GetSlotFloorNumber(Base, Rebirth.Value)
						if SlotFloorNumber == FloorNumber then
							local ProximityPrompt = ThingValue.Value:FindFirstChildWhichIsA("ProximityPrompt", true)
							if ProximityPrompt then
								SetProperties.Client(TouchingPlayer, ProximityPrompt, {Enabled = false})
							end
						end
					end
				end
			end)

			table.insert(BasesConnections[Base], HitboxTouchedConnection)
			table.insert(BasesConnections[Base], HitboxTouchEndedConnection)
		end
	end

	for _, Slot in ipairs(Base.Slots:GetChildren()) do
		local Configuration = Slot:FindFirstChild("Configuration")
		if not Configuration then continue end

		local ThingValue = Configuration:FindFirstChild("Thing")
		if not ThingValue then continue end

		local ThingConnection = ThingValue:GetPropertyChangedSignal("Value"):Connect(function()
			local ThingInstance = ThingValue.Value
			if not ThingInstance then return end

			local Rebirth = Configuration:FindFirstChild("Rebirth")
			if not Rebirth then return end

			local SlotFloorNumber = GetSlotFloorNumber(Base, Rebirth.Value)
			if not SlotFloorNumber then return end

			local ProximityPrompt = ThingInstance:FindFirstChildWhichIsA("ProximityPrompt", true)
			if not ProximityPrompt then return end

			for PlayerInFloor, FloorNumber in pairs(PlayersInFloors) do
				if FloorNumber == SlotFloorNumber then
					SetProperties.Client(PlayerInFloor, ProximityPrompt, {Enabled = true})
				end
			end
		end)

		table.insert(BasesConnections[Base], ThingConnection)
	end
	
	local PlayerRemovingConnection = Players.PlayerRemoving:Connect(function(Player)
		PlayersInFloors[Player] = nil
	end)
	
	table.insert(BasesConnections[Base], PlayerRemovingConnection)
	
	LoadThings(Player)
end

local function ResetBase(Base)
	if not Base then return end

	if BasesConnections[Base] then
		for _, Connection in ipairs(BasesConnections[Base] or {}) do
			if Connection.Disconnect then
				Connection:Disconnect()
			end
		end

		BasesConnections[Base] = nil
	end

	if BasesData[Base] then
		BasesData[Base] = nil
	end

	Base.Configuration.Player.Value = nil
	
	local FriendsAttachment = Base.Friends:FindFirstChild("FriendsAttachment")
	if FriendsAttachment then FriendsAttachment:Destroy() end

	local FriendsSurfaceGui = Base.Friends:FindFirstChild("FriendsSurfaceGui")
	if FriendsSurfaceGui then FriendsSurfaceGui:Destroy() end
	
	local FriendsProximityPrompt = Base.Friends:FindFirstChild("ProximityPrompt")
	if FriendsProximityPrompt then FriendsProximityPrompt:Destroy() end

	local LockAttachment = Base.Lock:FindFirstChild("LockAttachment")
	if LockAttachment then LockAttachment:Destroy() end

	local MultiplierAttachment = Base.CollectZone:FindFirstChild("MultiplierAttachment")
	if MultiplierAttachment then MultiplierAttachment:Destroy() end

	local CollectZoneGui = Base.CollectZone:FindFirstChild("CollectZoneGui")
	if CollectZoneGui then CollectZoneGui:Destroy() end

	local OwnerGui = Base.Owner:FindFirstChild("OwnerGui")
	if OwnerGui then OwnerGui:Destroy() end
	
	local OwnerSurfaceGui = Base.Owner:FindFirstChild("OwnerSurfaceGui")
	if OwnerSurfaceGui then OwnerSurfaceGui:Destroy() end

	local RebirthsAmount = 0
	for _, Slot in ipairs(Base.Slots:GetChildren()) do
		local Configuration = Slot:FindFirstChild("Configuration")
		if not Configuration then continue end

		local Thing = Configuration:FindFirstChild("Thing") and Configuration.Thing.Value
		if Thing then
			Thing:Destroy()
		end

		local CollectAttachment = Slot:FindFirstChild("Collect") and Slot.Collect:FindFirstChild("CollectAttachment")
		if CollectAttachment then
			CollectAttachment:Destroy()
		end

		Configuration.Thing.Value = nil
		Configuration.Occupied.Value = false

		local Rebirth = Configuration:FindFirstChild("Rebirth")
		if not Rebirth then continue end

		local IsVisible = (RebirthsAmount >= Rebirth.Value)

		for _, Descendant in ipairs(Slot:GetDescendants()) do
			if Descendant:IsA("BasePart") then
				Descendant.Transparency = IsVisible and 0 or 1
				Descendant.CanCollide = IsVisible
			end
		end
	end

	local UnlockedFloors = GetUnlockedFloors(Base, RebirthsAmount)
	local UnlockedSet = {}
	for _, Floor in ipairs(UnlockedFloors) do
		UnlockedSet[Floor] = true
	end

	for _, Floor in ipairs(Base.Floors:GetChildren()) do
		local IsUnlocked = UnlockedSet[Floor] == true

		for _, Child in ipairs(Floor:GetChildren()) do
			if Child.Name == "Hitbox" then
				continue
			elseif Child.Name == "Doors" then
				for _, Door in ipairs(Child:GetChildren()) do
					local DoorProximityPrompt = Door.Hitbox:FindFirstChild("ProximityPrompt")
					if DoorProximityPrompt then DoorProximityPrompt:Destroy() end
				end
			else
				for _, Descendant in ipairs(Child:GetDescendants()) do
					if Descendant:IsA("BasePart") then
						Descendant.Transparency = IsUnlocked and 0 or 1
						Descendant.CanCollide = IsUnlocked
					end
				end
			end
		end

		if not IsUnlocked then
			for _, Descendant in ipairs(Floor:GetDescendants()) do
				if Descendant:IsA("BasePart") and Descendant.Name ~= "Hitbox" then
					Descendant.Transparency = 1
					Descendant.CanCollide = false
				end
			end
		end
	end
	
	local UnlockedDoors = GetUnlockedDoors(Base, RebirthsAmount)

	for _, Door in ipairs(UnlockedDoors) do
		for _, Descendant in ipairs(Door:GetDescendants()) do
			if not Descendant:IsA("BasePart") then continue end

			Descendant.Transparency = 1
			Descendant.CanCollide = false
		end
	end
end

task.spawn(function()
	for _, Base in ipairs(Bases:GetChildren()) do
		task.spawn(ResetBase, Base)
	end
end)

task.spawn(Things.Initialize)

Players.PlayerAdded:Connect(function(Player)
	local LeaderstatsFolder = Instance.new("Folder")
	LeaderstatsFolder.Name = "leaderstats"
	LeaderstatsFolder.Parent = Player

	local StealsValue = Instance.new("IntValue")
	StealsValue.Name = "Steals"
	StealsValue.Value = 0
	StealsValue.Parent = LeaderstatsFolder

	local RebirthsValue = Instance.new("IntValue")
	RebirthsValue.Name = "Rebirths"
	RebirthsValue.Value = 0
	RebirthsValue.Parent = LeaderstatsFolder

	local MoneyValue = Instance.new("IntValue")
	MoneyValue.Name = "Money"
	MoneyValue.Value = 0
	MoneyValue.Parent = LeaderstatsFolder

	local Configuration = Instance.new("Configuration")
	Configuration.Name = "Configuration"
	Configuration.Parent = Player

	local BaseValue = Instance.new("ObjectValue")
	BaseValue.Name = "Base"
	BaseValue.Value = nil
	BaseValue.Parent = Configuration

	local FriendsValue = Instance.new("NumberValue")
	FriendsValue.Name = "Friends"
	FriendsValue.Value = 0
	FriendsValue.Parent = Configuration

	local MultiplierValue = Instance.new("NumberValue")
	MultiplierValue.Name = "Multiplier"
	MultiplierValue.Value = 1
	MultiplierValue.Parent = Configuration

	local IndexMultiplierValue = Instance.new("NumberValue")
	IndexMultiplierValue.Name = "IndexMultiplier"
	IndexMultiplierValue.Value = 0
	IndexMultiplierValue.Parent = Configuration

	task.spawn(SetBase, Player)

	local UserId = Player.UserId

	if UserId <= 0 then
		MoneyValue.Value = 1000

		return 
	end

	local UserIdString = tostring(UserId)

	local StealsSavedData, RebirthsSavedData, MoneySavedData
	local Success, Error = pcall(function()
		StealsSavedData = StealsOrderedDataStore:GetAsync(UserIdString)
		RebirthsSavedData = RebirthsOrderedDataStore:GetAsync(UserIdString)
		MoneySavedData = MoneyOrderedDataStore:GetAsync(UserIdString)
	end)

	if Success then
		if StealsSavedData then StealsValue.Value = StealsSavedData end
		if RebirthsSavedData then RebirthsValue.Value = RebirthsSavedData end
		if MoneySavedData then
			MoneyValue.Value = MoneySavedData
		else
			MoneyValue.Value = 1000
		end
	end

	FriendsValue:GetPropertyChangedSignal("Value"):Connect(function()
		UpdateMultiplier(Player)
	end)

	RebirthsValue:GetPropertyChangedSignal("Value"):Connect(function()
		UpdateMultiplier(Player)
		UpdateBase(Player)
	end)

	IndexMultiplierValue:GetPropertyChangedSignal("Value"):Connect(function()
		UpdateMultiplier(Player)
	end)

	UpdateFriends()
	UpdateMultiplier(Player)
	UpdateBase(Player)
	RefreshFriends()
	
	Player.CharacterAdded:Once(function()
		UpdateBase(Player)
		RefreshFriends()
	end)
end)

Players.PlayerRemoving:Connect(function(Player)
	local UserId = Player.UserId
	if UserId < 1 then return end

	local UserIdString = tostring(UserId)

	SaveThings(Player) 
	UpdateFriends()
	RefreshFriends()
	
	local LeaderstatsFolder = Player:FindFirstChild("leaderstats")
	if not LeaderstatsFolder then return end

	pcall(function()
		StealsOrderedDataStore:SetAsync(UserIdString, LeaderstatsFolder.Steals.Value)
		RebirthsOrderedDataStore:SetAsync(UserIdString, LeaderstatsFolder.Rebirths.Value)
		MoneyOrderedDataStore:SetAsync(UserIdString, LeaderstatsFolder.Money.Value)
	end)

	local Configuration = Player:FindFirstChild("Configuration")
	local Base = Configuration and Configuration:FindFirstChild("Base") and Configuration.Base.Value
	if not Base then return end

	ResetBase(Base)
end)

game:BindToClose(function()
	for _, Player in ipairs(Players:GetPlayers()) do
		local UserId = Player.UserId
		if UserId < 1 then return end

		local UserIdString = tostring(UserId)

		SaveThings(Player) 

		local LeaderstatsFolder = Player:FindFirstChild("leaderstats")
		if not LeaderstatsFolder then return end

		pcall(function()
			StealsOrderedDataStore:SetAsync(UserIdString, LeaderstatsFolder.Steals.Value)
			RebirthsOrderedDataStore:SetAsync(UserIdString, LeaderstatsFolder.Rebirths.Value)
			MoneyOrderedDataStore:SetAsync(UserIdString, LeaderstatsFolder.Money.Value)
		end)

		local Configuration = Player:FindFirstChild("Configuration")
		local Base = Configuration and Configuration:FindFirstChild("Base") and Configuration.Base.Value
		if not Base then return end

		ResetBase(Base)
	end
end)

task.spawn(function()
	while true do
		RefreshFriends()
		task.wait(1)
	end
end)
